{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.OfflineModuleEventEmitter = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _reactNative = require(\"react-native\");\n\nvar _utils = require(\"../../utils\");\n\nvar _OfflineCreatePackOptions = _interopRequireDefault(require(\"./OfflineCreatePackOptions\"));\n\nvar _OfflinePack = _interopRequireDefault(require(\"./OfflinePack\"));\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[typeof Symbol === \"function\" ? Symbol.iterator : \"@@iterator\"] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } it = o[typeof Symbol === \"function\" ? Symbol.iterator : \"@@iterator\"](); return it.next.bind(it); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar MapboxGL = _reactNative.NativeModules.MGLModule;\nvar MapboxGLOfflineManager = _reactNative.NativeModules.MGLOfflineModule;\nvar OfflineModuleEventEmitter = new _reactNative.NativeEventEmitter(MapboxGLOfflineManager);\nexports.OfflineModuleEventEmitter = OfflineModuleEventEmitter;\n\nvar OfflineManager = function () {\n  function OfflineManager() {\n    (0, _classCallCheck2.default)(this, OfflineManager);\n    this._hasInitialized = false;\n    this._offlinePacks = {};\n    this._progressListeners = {};\n    this._errorListeners = {};\n    this._onProgress = this._onProgress.bind(this);\n    this._onError = this._onError.bind(this);\n  }\n\n  (0, _createClass2.default)(OfflineManager, [{\n    key: \"createPack\",\n    value: function createPack(options, progressListener, errorListener) {\n      var packOptions, nativeOfflinePack;\n      return _regenerator.default.async(function createPack$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return _regenerator.default.awrap(this._initialize());\n\n            case 2:\n              packOptions = new _OfflineCreatePackOptions.default(options);\n\n              if (!this._offlinePacks[packOptions.name]) {\n                _context.next = 5;\n                break;\n              }\n\n              throw new Error(\"Offline pack with name \" + packOptions.name + \" already exists.\");\n\n            case 5:\n              this.subscribe(packOptions.name, progressListener, errorListener);\n              _context.next = 8;\n              return _regenerator.default.awrap(MapboxGLOfflineManager.createPack(packOptions));\n\n            case 8:\n              nativeOfflinePack = _context.sent;\n              this._offlinePacks[packOptions.name] = new _OfflinePack.default(nativeOfflinePack);\n\n            case 10:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"deletePack\",\n    value: function deletePack(name) {\n      var offlinePack;\n      return _regenerator.default.async(function deletePack$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              if (name) {\n                _context2.next = 2;\n                break;\n              }\n\n              return _context2.abrupt(\"return\");\n\n            case 2:\n              _context2.next = 4;\n              return _regenerator.default.awrap(this._initialize());\n\n            case 4:\n              offlinePack = this._offlinePacks[name];\n\n              if (!offlinePack) {\n                _context2.next = 9;\n                break;\n              }\n\n              _context2.next = 8;\n              return _regenerator.default.awrap(MapboxGLOfflineManager.deletePack(name));\n\n            case 8:\n              delete this._offlinePacks[name];\n\n            case 9:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"resetDatabase\",\n    value: function resetDatabase() {\n      return _regenerator.default.async(function resetDatabase$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.next = 2;\n              return _regenerator.default.awrap(this._initialize());\n\n            case 2:\n              _context3.next = 4;\n              return _regenerator.default.awrap(MapboxGLOfflineManager.resetDatabase());\n\n            case 4:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"getPacks\",\n    value: function getPacks() {\n      var _this = this;\n\n      return _regenerator.default.async(function getPacks$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              _context4.next = 2;\n              return _regenerator.default.awrap(this._initialize());\n\n            case 2:\n              return _context4.abrupt(\"return\", Object.keys(this._offlinePacks).map(function (name) {\n                return _this._offlinePacks[name];\n              }));\n\n            case 3:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"getPack\",\n    value: function getPack(name) {\n      return _regenerator.default.async(function getPack$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              _context5.next = 2;\n              return _regenerator.default.awrap(this._initialize());\n\n            case 2:\n              return _context5.abrupt(\"return\", this._offlinePacks[name]);\n\n            case 3:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"mergeOfflineRegions\",\n    value: function mergeOfflineRegions(path) {\n      return _regenerator.default.async(function mergeOfflineRegions$(_context6) {\n        while (1) {\n          switch (_context6.prev = _context6.next) {\n            case 0:\n              _context6.next = 2;\n              return _regenerator.default.awrap(this._initialize());\n\n            case 2:\n              return _context6.abrupt(\"return\", MapboxGLOfflineManager.mergeOfflineRegions(path));\n\n            case 3:\n            case \"end\":\n              return _context6.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"setTileCountLimit\",\n    value: function setTileCountLimit(limit) {\n      MapboxGLOfflineManager.setTileCountLimit(limit);\n    }\n  }, {\n    key: \"setProgressEventThrottle\",\n    value: function setProgressEventThrottle(throttleValue) {\n      MapboxGLOfflineManager.setProgressEventThrottle(throttleValue);\n    }\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(packName, progressListener, errorListener) {\n      var totalProgressListeners, totalErrorListeners;\n      return _regenerator.default.async(function subscribe$(_context7) {\n        while (1) {\n          switch (_context7.prev = _context7.next) {\n            case 0:\n              totalProgressListeners = Object.keys(this._progressListeners).length;\n\n              if ((0, _utils.isFunction)(progressListener)) {\n                if (totalProgressListeners === 0) {\n                  OfflineModuleEventEmitter.addListener(MapboxGL.OfflineCallbackName.Progress, this._onProgress);\n                }\n\n                this._progressListeners[packName] = progressListener;\n              }\n\n              totalErrorListeners = Object.keys(this._errorListeners).length;\n\n              if ((0, _utils.isFunction)(errorListener)) {\n                if (totalErrorListeners === 0) {\n                  OfflineModuleEventEmitter.addListener(MapboxGL.OfflineCallbackName.Error, this._onError);\n                }\n\n                this._errorListeners[packName] = errorListener;\n              }\n\n              if (!((0, _utils.isAndroid)() && this._offlinePacks[packName])) {\n                _context7.next = 13;\n                break;\n              }\n\n              _context7.prev = 5;\n              _context7.next = 8;\n              return _regenerator.default.awrap(MapboxGLOfflineManager.setPackObserver(packName));\n\n            case 8:\n              _context7.next = 13;\n              break;\n\n            case 10:\n              _context7.prev = 10;\n              _context7.t0 = _context7[\"catch\"](5);\n              console.log('Unable to set pack observer', _context7.t0);\n\n            case 13:\n            case \"end\":\n              return _context7.stop();\n          }\n        }\n      }, null, this, [[5, 10]], Promise);\n    }\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe(packName) {\n      delete this._progressListeners[packName];\n      delete this._errorListeners[packName];\n\n      if (Object.keys(this._progressListeners).length === 0) {\n        OfflineModuleEventEmitter.removeListener(MapboxGL.OfflineCallbackName.Progress, this._onProgress);\n      }\n\n      if (Object.keys(this._errorListeners).length === 0) {\n        OfflineModuleEventEmitter.removeListener(MapboxGL.OfflineCallbackName.Error, this._onError);\n      }\n    }\n  }, {\n    key: \"_initialize\",\n    value: function _initialize() {\n      var _this2 = this;\n\n      return new Promise(function _callee(resolve, reject) {\n        var nativeOfflinePacks, _iterator, _step, nativeOfflinePack, offlinePack;\n\n        return _regenerator.default.async(function _callee$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                if (!_this2._hasInitialized) {\n                  _context8.next = 2;\n                  break;\n                }\n\n                return _context8.abrupt(\"return\", resolve(true));\n\n              case 2:\n                _context8.prev = 2;\n                _context8.next = 5;\n                return _regenerator.default.awrap(MapboxGLOfflineManager.getPacks());\n\n              case 5:\n                nativeOfflinePacks = _context8.sent;\n\n                for (_iterator = _createForOfIteratorHelperLoose(nativeOfflinePacks); !(_step = _iterator()).done;) {\n                  nativeOfflinePack = _step.value;\n                  offlinePack = new _OfflinePack.default(nativeOfflinePack);\n                  _this2._offlinePacks[offlinePack.name] = offlinePack;\n                }\n\n                _context8.next = 13;\n                break;\n\n              case 9:\n                _context8.prev = 9;\n                _context8.t0 = _context8[\"catch\"](2);\n                reject(_context8.t0);\n                return _context8.abrupt(\"return\");\n\n              case 13:\n                _this2._hasInitialized = true;\n                return _context8.abrupt(\"return\", resolve(true));\n\n              case 15:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, null, null, [[2, 9]], Promise);\n      });\n    }\n  }, {\n    key: \"_onProgress\",\n    value: function _onProgress(e) {\n      var _e$payload = e.payload,\n          name = _e$payload.name,\n          state = _e$payload.state;\n\n      if (!this._hasListeners(name, this._progressListeners)) {\n        return;\n      }\n\n      var pack = this._offlinePacks[name];\n\n      this._progressListeners[name](pack, e.payload);\n\n      if (state === MapboxGL.OfflinePackDownloadState.Complete) {\n        this.unsubscribe(name);\n      }\n    }\n  }, {\n    key: \"_onError\",\n    value: function _onError(e) {\n      var name = e.payload.name;\n\n      if (!this._hasListeners(name, this._errorListeners)) {\n        return;\n      }\n\n      var pack = this._offlinePacks[name];\n\n      this._errorListeners[name](pack, e.payload);\n    }\n  }, {\n    key: \"_hasListeners\",\n    value: function _hasListeners(name, listenerMap) {\n      return !(0, _utils.isUndefined)(this._offlinePacks[name]) && (0, _utils.isFunction)(listenerMap[name]);\n    }\n  }]);\n  return OfflineManager;\n}();\n\nvar offlineManager = new OfflineManager();\nvar _default = offlineManager;\nexports.default = _default;","map":{"version":3,"sources":["/Users/angelaranibar/Erick/ParqueosCochalosMovil-master/Movil/ParqueosCochalos/node_modules/@react-native-mapbox-gl/maps/javascript/modules/offline/offlineManager.js"],"names":["MapboxGL","NativeModules","MGLModule","MapboxGLOfflineManager","MGLOfflineModule","OfflineModuleEventEmitter","NativeEventEmitter","OfflineManager","_hasInitialized","_offlinePacks","_progressListeners","_errorListeners","_onProgress","bind","_onError","options","progressListener","errorListener","_initialize","packOptions","OfflineCreatePackOptions","name","Error","subscribe","createPack","nativeOfflinePack","OfflinePack","offlinePack","deletePack","resetDatabase","Object","keys","map","path","mergeOfflineRegions","limit","setTileCountLimit","throttleValue","setProgressEventThrottle","packName","totalProgressListeners","length","addListener","OfflineCallbackName","Progress","totalErrorListeners","setPackObserver","console","log","removeListener","Promise","resolve","reject","getPacks","nativeOfflinePacks","e","payload","state","_hasListeners","pack","OfflinePackDownloadState","Complete","unsubscribe","listenerMap","offlineManager"],"mappings":"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","sourcesContent":["import {NativeModules, NativeEventEmitter} from 'react-native';\n\nimport {isUndefined, isFunction, isAndroid} from '../../utils';\n\nimport OfflineCreatePackOptions from './OfflineCreatePackOptions';\nimport OfflinePack from './OfflinePack';\n\nconst MapboxGL = NativeModules.MGLModule;\nconst MapboxGLOfflineManager = NativeModules.MGLOfflineModule;\nexport const OfflineModuleEventEmitter = new NativeEventEmitter(\n  MapboxGLOfflineManager,\n);\n\n/**\n * OfflineManager implements a singleton (shared object) that manages offline packs.\n * All of this class’s instance methods are asynchronous, reflecting the fact that offline resources are stored in a database.\n * The shared object maintains a canonical collection of offline packs.\n */\nclass OfflineManager {\n  constructor() {\n    this._hasInitialized = false;\n    this._offlinePacks = {};\n\n    this._progressListeners = {};\n    this._errorListeners = {};\n\n    this._onProgress = this._onProgress.bind(this);\n    this._onError = this._onError.bind(this);\n  }\n\n  /**\n   * Creates and registers an offline pack that downloads the resources needed to use the given region offline.\n   *\n   * @example\n   *\n   * const progressListener = (offlineRegion, status) => console.log(offlineRegion, status);\n   * const errorListener = (offlineRegion, err) => console.log(offlineRegion, err);\n   *\n   * await MapboxGL.offlineManager.createPack({\n   *   name: 'offlinePack',\n   *   styleURL: 'mapbox://...',\n   *   minZoom: 14,\n   *   maxZoom: 20,\n   *   bounds: [[neLng, neLat], [swLng, swLat]]\n   * }, progressListener, errorListener)\n   *\n   * @param  {OfflineCreatePackOptions} options Create options for a offline pack that specifices zoom levels, style url, and the region to download.\n   * @param  {Callback=} progressListener Callback that listens for status events while downloading the offline resource.\n   * @param  {Callback=} errorListener Callback that listens for status events while downloading the offline resource.\n   * @return {void}\n   */\n  async createPack(options, progressListener, errorListener) {\n    await this._initialize();\n\n    const packOptions = new OfflineCreatePackOptions(options);\n\n    if (this._offlinePacks[packOptions.name]) {\n      throw new Error(\n        `Offline pack with name ${packOptions.name} already exists.`,\n      );\n    }\n\n    this.subscribe(packOptions.name, progressListener, errorListener);\n    const nativeOfflinePack = await MapboxGLOfflineManager.createPack(\n      packOptions,\n    );\n    this._offlinePacks[packOptions.name] = new OfflinePack(nativeOfflinePack);\n  }\n\n  /**\n   * Unregisters the given offline pack and allows resources that are no longer required by any remaining packs to be potentially freed.\n   *\n   * @example\n   * await MapboxGL.offlineManager.deletePack('packName')\n   *\n   * @param  {String}  name  Name of the offline pack.\n   * @return {void}\n   */\n  async deletePack(name) {\n    if (!name) {\n      return;\n    }\n\n    await this._initialize();\n\n    const offlinePack = this._offlinePacks[name];\n    if (offlinePack) {\n      await MapboxGLOfflineManager.deletePack(name);\n      delete this._offlinePacks[name];\n    }\n  }\n\n  /**\n   * Deletes the existing database, which includes both the ambient cache and offline packs, then reinitializes it.\n   *\n   * @example\n   * await MapboxGL.offlineManager.resetDatabase();\n   *\n   * @return {void}\n   */\n  async resetDatabase() {\n    await this._initialize();\n    await MapboxGLOfflineManager.resetDatabase();\n  }\n\n  /**\n   * Retrieves all the current offline packs that are stored in the database.\n   *\n   * @example\n   * const offlinePacks = await MapboxGL.offlineManager.getPacks();\n   *\n   * @return {Array<OfflinePack>}\n   */\n  async getPacks() {\n    await this._initialize();\n    return Object.keys(this._offlinePacks).map(\n      name => this._offlinePacks[name],\n    );\n  }\n\n  /**\n   * Retrieves an offline pack that is stored in the database by name.\n   *\n   * @example\n   * const offlinePack = await MapboxGL.offlineManager.getPack();\n   *\n   * @param  {String}  name  Name of the offline pack.\n   * @return {OfflinePack}\n   */\n  async getPack(name) {\n    await this._initialize();\n    return this._offlinePacks[name];\n  }\n\n  /**\n   * Sideloads offline db\n   *\n   * @example\n   * await MapboxGL.offlineManager.mergeOfflineRegions(path);\n   *\n   * @param {String} path Path to offline tile db on file system.\n   * @return {void}\n   */\n  async mergeOfflineRegions(path) {\n    await this._initialize();\n    return MapboxGLOfflineManager.mergeOfflineRegions(path);\n  }\n\n  /**\n   * Sets the maximum number of Mapbox-hosted tiles that may be downloaded and stored on the current device.\n   * The Mapbox Terms of Service prohibits changing or bypassing this limit without permission from Mapbox.\n   *\n   * @example\n   * MapboxGL.offlineManager.setTileCountLimit(1000);\n   *\n   * @param {Number} limit Map tile limit count.\n   * @return {void}\n   */\n  setTileCountLimit(limit) {\n    MapboxGLOfflineManager.setTileCountLimit(limit);\n  }\n\n  /**\n   * Sets the value at which download status events will be sent over the React Native bridge.\n   * These events happening very very fast default is 500ms.\n   *\n   * @example\n   * MapboxGL.setProgressEventThrottle(500);\n   *\n   * @param {Number} throttleValue event throttle value in ms.\n   * @return {void}\n   */\n  setProgressEventThrottle(throttleValue) {\n    MapboxGLOfflineManager.setProgressEventThrottle(throttleValue);\n  }\n\n  /**\n   * Subscribe to download status/error events for the requested offline pack.\n   * Note that createPack calls this internally if listeners are provided.\n   *\n   * @example\n   * const progressListener = (offlinePack, status) => console.log(offlinePack, status)\n   * const errorListener = (offlinePack, err) => console.log(offlinePack, err)\n   * MapboxGL.offlineManager.subscribe('packName', progressListener, errorListener)\n   *\n   * @param  {String} packName           Name of the offline pack.\n   * @param  {Callback} progressListener Callback that listens for status events while downloading the offline resource.\n   * @param  {Callback} errorListener      Callback that listens for status events while downloading the offline resource.\n   * @return {void}\n   */\n  async subscribe(packName, progressListener, errorListener) {\n    const totalProgressListeners = Object.keys(this._progressListeners).length;\n    if (isFunction(progressListener)) {\n      if (totalProgressListeners === 0) {\n        OfflineModuleEventEmitter.addListener(\n          MapboxGL.OfflineCallbackName.Progress,\n          this._onProgress,\n        );\n      }\n      this._progressListeners[packName] = progressListener;\n    }\n\n    const totalErrorListeners = Object.keys(this._errorListeners).length;\n    if (isFunction(errorListener)) {\n      if (totalErrorListeners === 0) {\n        OfflineModuleEventEmitter.addListener(\n          MapboxGL.OfflineCallbackName.Error,\n          this._onError,\n        );\n      }\n      this._errorListeners[packName] = errorListener;\n    }\n\n    // we need to manually set the pack observer on Android\n    // if we're resuming a pack download instead of going thru the create flow\n    if (isAndroid() && this._offlinePacks[packName]) {\n      try {\n        // manually set a listener, since listeners are only set on create flow\n        await MapboxGLOfflineManager.setPackObserver(packName);\n      } catch (e) {\n        console.log('Unable to set pack observer', e); // eslint-disable-line\n      }\n    }\n  }\n\n  /**\n   * Unsubscribes any listeners associated with the offline pack.\n   * It's a good idea to call this on componentWillUnmount.\n   *\n   * @example\n   * MapboxGL.offlineManager.unsubscribe('packName')\n   *\n   * @param  {String} packName Name of the offline pack.\n   * @return {void}\n   */\n  unsubscribe(packName) {\n    delete this._progressListeners[packName];\n    delete this._errorListeners[packName];\n\n    if (Object.keys(this._progressListeners).length === 0) {\n      OfflineModuleEventEmitter.removeListener(\n        MapboxGL.OfflineCallbackName.Progress,\n        this._onProgress,\n      );\n    }\n\n    if (Object.keys(this._errorListeners).length === 0) {\n      OfflineModuleEventEmitter.removeListener(\n        MapboxGL.OfflineCallbackName.Error,\n        this._onError,\n      );\n    }\n  }\n\n  _initialize() {\n    return new Promise(async (resolve, reject) => {\n      if (this._hasInitialized) {\n        return resolve(true);\n      }\n\n      try {\n        const nativeOfflinePacks = await MapboxGLOfflineManager.getPacks();\n\n        for (const nativeOfflinePack of nativeOfflinePacks) {\n          const offlinePack = new OfflinePack(nativeOfflinePack);\n          this._offlinePacks[offlinePack.name] = offlinePack;\n        }\n      } catch (e) {\n        reject(e);\n        return;\n      }\n\n      this._hasInitialized = true;\n      return resolve(true);\n    });\n  }\n\n  _onProgress(e) {\n    const {name, state} = e.payload;\n\n    if (!this._hasListeners(name, this._progressListeners)) {\n      return;\n    }\n\n    const pack = this._offlinePacks[name];\n    this._progressListeners[name](pack, e.payload);\n\n    // cleanup listeners now that they are no longer needed\n    if (state === MapboxGL.OfflinePackDownloadState.Complete) {\n      this.unsubscribe(name);\n    }\n  }\n\n  _onError(e) {\n    const {name} = e.payload;\n\n    if (!this._hasListeners(name, this._errorListeners)) {\n      return;\n    }\n\n    const pack = this._offlinePacks[name];\n    this._errorListeners[name](pack, e.payload);\n  }\n\n  _hasListeners(name, listenerMap) {\n    return (\n      !isUndefined(this._offlinePacks[name]) && isFunction(listenerMap[name])\n    );\n  }\n}\n\nconst offlineManager = new OfflineManager();\nexport default offlineManager;\n"]},"metadata":{},"sourceType":"script"}