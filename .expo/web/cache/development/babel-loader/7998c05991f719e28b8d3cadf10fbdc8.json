{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.NATIVE_MODULE_NAME = void 0;\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _reactNative = require(\"react-native\");\n\nvar _utils = require(\"../utils\");\n\nvar geoUtils = _interopRequireWildcard(require(\"../utils/geoUtils\"));\n\nvar _jsxFileName = \"/Users/angelaranibar/Erick/ParqueosCochalosMovil-master/Movil/ParqueosCochalos/node_modules/@react-native-mapbox-gl/maps/javascript/components/Camera.js\";\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[typeof Symbol === \"function\" ? Symbol.iterator : \"@@iterator\"] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } it = o[typeof Symbol === \"function\" ? Symbol.iterator : \"@@iterator\"](); return it.next.bind(it); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nvar MapboxGL = _reactNative.NativeModules.MGLModule;\nvar NATIVE_MODULE_NAME = 'RCTMGLCamera';\nexports.NATIVE_MODULE_NAME = NATIVE_MODULE_NAME;\nvar SettingsPropTypes = {\n  centerCoordinate: _propTypes.default.arrayOf(_propTypes.default.number),\n  heading: _propTypes.default.number,\n  pitch: _propTypes.default.number,\n  bounds: _propTypes.default.shape({\n    ne: _propTypes.default.arrayOf(_propTypes.default.number).isRequired,\n    sw: _propTypes.default.arrayOf(_propTypes.default.number).isRequired,\n    paddingLeft: _propTypes.default.number,\n    paddingRight: _propTypes.default.number,\n    paddingTop: _propTypes.default.number,\n    paddingBottom: _propTypes.default.number\n  }),\n  zoomLevel: _propTypes.default.number\n};\n\nvar Camera = function (_React$Component) {\n  (0, _inherits2.default)(Camera, _React$Component);\n\n  var _super = _createSuper(Camera);\n\n  function Camera() {\n    (0, _classCallCheck2.default)(this, Camera);\n    return _super.apply(this, arguments);\n  }\n\n  (0, _createClass2.default)(Camera, [{\n    key: \"UNSAFE_componentWillReceiveProps\",\n    value: function UNSAFE_componentWillReceiveProps(nextProps) {\n      this._handleCameraChange(this.props, nextProps);\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate() {\n      return false;\n    }\n  }, {\n    key: \"_handleCameraChange\",\n    value: function _handleCameraChange(currentCamera, nextCamera) {\n      var hasCameraChanged = this._hasCameraChanged(currentCamera, nextCamera);\n\n      if (!hasCameraChanged) {\n        return;\n      }\n\n      if (currentCamera.followUserLocation && !nextCamera.followUserLocation) {\n        this.refs.camera.setNativeProps({\n          followUserLocation: false\n        });\n        return;\n      }\n\n      if (!currentCamera.followUserLocation && nextCamera.followUserLocation) {\n        this.refs.camera.setNativeProps({\n          followUserLocation: true\n        });\n      }\n\n      if (nextCamera.followUserLocation) {\n        this.refs.camera.setNativeProps({\n          followUserMode: nextCamera.followUserMode,\n          followPitch: nextCamera.followPitch || nextCamera.pitch,\n          followHeading: nextCamera.followHeading || nextCamera.heading,\n          followZoomLevel: nextCamera.followZoomLevel || nextCamera.zoomLevel\n        });\n        return;\n      }\n\n      var cameraConfig = {\n        animationMode: nextCamera.animationMode,\n        animationDuration: nextCamera.animationDuration,\n        zoomLevel: nextCamera.zoomLevel,\n        pitch: nextCamera.pitch,\n        heading: nextCamera.heading\n      };\n\n      if (nextCamera.bounds && this._hasBoundsChanged(currentCamera, nextCamera)) {\n        cameraConfig.bounds = nextCamera.bounds;\n      } else {\n        cameraConfig.centerCoordinate = nextCamera.centerCoordinate;\n      }\n\n      this._setCamera(cameraConfig);\n    }\n  }, {\n    key: \"_hasCameraChanged\",\n    value: function _hasCameraChanged(currentCamera, nextCamera) {\n      var c = currentCamera;\n      var n = nextCamera;\n      var hasDefaultPropsChanged = c.heading !== n.heading || this._hasCenterCoordinateChanged(c, n) || this._hasBoundsChanged(c, n) || c.pitch !== n.pitch || c.zoomLevel !== n.zoomLevel || c.triggerKey !== n.triggerKey;\n      var hasFollowPropsChanged = c.followUserLocation !== n.followUserLocation || c.followUserMode !== n.followUserMode || c.followZoomLevel !== n.followZoomLevel || c.followHeading !== n.followHeading || c.followPitch !== n.followPitch;\n      var hasAnimationPropsChanged = c.animationMode !== n.animationMode || c.animationDuration !== n.animationDuration;\n      return hasDefaultPropsChanged || hasFollowPropsChanged || hasAnimationPropsChanged;\n    }\n  }, {\n    key: \"_hasCenterCoordinateChanged\",\n    value: function _hasCenterCoordinateChanged(currentCamera, nextCamera) {\n      var cC = currentCamera.centerCoordinate;\n      var nC = nextCamera.centerCoordinate;\n\n      if ((0, _utils.existenceChange)(cC, nC)) {\n        return true;\n      }\n\n      if (!cC && !nC) {\n        return false;\n      }\n\n      var isLngDiff = currentCamera.centerCoordinate[0] !== nextCamera.centerCoordinate[0];\n      var isLatDiff = currentCamera.centerCoordinate[1] !== nextCamera.centerCoordinate[1];\n      return isLngDiff || isLatDiff;\n    }\n  }, {\n    key: \"_hasBoundsChanged\",\n    value: function _hasBoundsChanged(currentCamera, nextCamera) {\n      var cB = currentCamera.bounds;\n      var nB = nextCamera.bounds;\n\n      if (!cB && !nB) {\n        return false;\n      }\n\n      if ((0, _utils.existenceChange)(cB, nB)) {\n        return true;\n      }\n\n      return cB.ne[0] !== nB.ne[0] || cB.ne[1] !== nB.ne[1] || cB.sw[0] !== nB.sw[0] || cB.sw[1] !== nB.sw[1] || cB.paddingTop !== nB.paddingTop || cB.paddingLeft !== nB.paddingLeft || cB.paddingRight !== nB.paddingRight || cB.paddingBottom !== nB.paddingBottom;\n    }\n  }, {\n    key: \"fitBounds\",\n    value: function fitBounds(northEastCoordinates, southWestCoordinates) {\n      var padding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var animationDuration = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.0;\n      var pad = {\n        paddingLeft: 0,\n        paddingRight: 0,\n        paddingTop: 0,\n        paddingBottom: 0\n      };\n\n      if (Array.isArray(padding)) {\n        if (padding.length === 2) {\n          pad.paddingTop = padding[0];\n          pad.paddingBottom = padding[0];\n          pad.paddingLeft = padding[1];\n          pad.paddingRight = padding[1];\n        } else if (padding.length === 4) {\n          pad.paddingTop = padding[0];\n          pad.paddingRight = padding[1];\n          pad.paddingBottom = padding[2];\n          pad.paddingLeft = padding[3];\n        }\n      } else {\n        pad.paddingLeft = padding;\n        pad.paddingRight = padding;\n        pad.paddingTop = padding;\n        pad.paddingBottom = padding;\n      }\n\n      return this.setCamera({\n        bounds: _objectSpread({\n          ne: northEastCoordinates,\n          sw: southWestCoordinates\n        }, pad),\n        animationDuration: animationDuration,\n        animationMode: Camera.Mode.Ease\n      });\n    }\n  }, {\n    key: \"flyTo\",\n    value: function flyTo(coordinates) {\n      var animationDuration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2000;\n      return this.setCamera({\n        centerCoordinate: coordinates,\n        animationDuration: animationDuration,\n        animationMode: Camera.Mode.Flight\n      });\n    }\n  }, {\n    key: \"moveTo\",\n    value: function moveTo(coordinates) {\n      var animationDuration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return this._setCamera({\n        centerCoordinate: coordinates,\n        animationDuration: animationDuration\n      });\n    }\n  }, {\n    key: \"zoomTo\",\n    value: function zoomTo(zoomLevel) {\n      var animationDuration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2000;\n      return this._setCamera({\n        zoomLevel: zoomLevel,\n        animationDuration: animationDuration,\n        animationMode: Camera.Mode.Flight\n      });\n    }\n  }, {\n    key: \"setCamera\",\n    value: function setCamera() {\n      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      this._setCamera(config);\n    }\n  }, {\n    key: \"_setCamera\",\n    value: function _setCamera() {\n      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var cameraConfig = {};\n\n      if (config.stops) {\n        cameraConfig.stops = [];\n\n        for (var _iterator = _createForOfIteratorHelperLoose(config.stops), _step; !(_step = _iterator()).done;) {\n          var stop = _step.value;\n          cameraConfig.stops.push(this._createStopConfig(stop));\n        }\n      } else {\n        cameraConfig = this._createStopConfig(config);\n      }\n\n      this.refs.camera.setNativeProps({\n        stop: cameraConfig\n      });\n    }\n  }, {\n    key: \"_createDefaultCamera\",\n    value: function _createDefaultCamera() {\n      if (this.defaultCamera) {\n        return this.defaultCamera;\n      }\n\n      if (!this.props.defaultSettings) {\n        return null;\n      }\n\n      this.defaultCamera = this._createStopConfig(_objectSpread({}, this.props.defaultSettings, {\n        animationMode: Camera.Mode.Move\n      }), true);\n      return this.defaultCamera;\n    }\n  }, {\n    key: \"_createStopConfig\",\n    value: function _createStopConfig() {\n      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var ignoreFollowUserLocation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (this.props.followUserLocation && !ignoreFollowUserLocation) {\n        return null;\n      }\n\n      var stopConfig = {\n        mode: this._getNativeCameraMode(config),\n        pitch: config.pitch,\n        heading: config.heading,\n        duration: config.animationDuration || 0,\n        zoom: config.zoomLevel\n      };\n\n      if (config.centerCoordinate) {\n        stopConfig.centerCoordinate = (0, _utils.toJSONString)(geoUtils.makePoint(config.centerCoordinate));\n      }\n\n      if (config.bounds && config.bounds.ne && config.bounds.sw) {\n        var _config$bounds = config.bounds,\n            ne = _config$bounds.ne,\n            sw = _config$bounds.sw,\n            paddingLeft = _config$bounds.paddingLeft,\n            paddingRight = _config$bounds.paddingRight,\n            paddingTop = _config$bounds.paddingTop,\n            paddingBottom = _config$bounds.paddingBottom;\n        stopConfig.bounds = (0, _utils.toJSONString)(geoUtils.makeLatLngBounds(ne, sw));\n        stopConfig.boundsPaddingTop = paddingTop || 0;\n        stopConfig.boundsPaddingRight = paddingRight || 0;\n        stopConfig.boundsPaddingBottom = paddingBottom || 0;\n        stopConfig.boundsPaddingLeft = paddingLeft || 0;\n      }\n\n      return stopConfig;\n    }\n  }, {\n    key: \"_getNativeCameraMode\",\n    value: function _getNativeCameraMode(config) {\n      switch (config.animationMode) {\n        case Camera.Mode.Flight:\n          return MapboxGL.CameraModes.Flight;\n\n        case Camera.Mode.Move:\n          return MapboxGL.CameraModes.None;\n\n        default:\n          return MapboxGL.CameraModes.Ease;\n      }\n    }\n  }, {\n    key: \"_getAlignment\",\n    value: function _getAlignment(coordinate, zoomLevel) {\n      var region = geoUtils.getOrCalculateVisibleRegion(coordinate, zoomLevel, this.props._mapWidth, this.props._mapHeight, this.props._region);\n      var topLeftCorner = [region.sw[0], region.ne[1]];\n      var topRightCorner = [region.ne[0], region.ne[1]];\n      var bottomLeftCorner = [region.sw[0], region.sw[1]];\n      var verticalLineString = geoUtils.makeLineString([topLeftCorner, bottomLeftCorner]);\n      var horizontalLineString = geoUtils.makeLineString([topLeftCorner, topRightCorner]);\n      var distVertical = geoUtils.calculateDistance(topLeftCorner, bottomLeftCorner);\n      var distHorizontal = geoUtils.calculateDistance(topLeftCorner, topRightCorner);\n      var verticalPoint = geoUtils.pointAlongLine(verticalLineString, distVertical * this.props.alignment[0]);\n      var horizontalPoint = geoUtils.pointAlongLine(horizontalLineString, distHorizontal * this.props.alignment[1]);\n      return [verticalPoint[0], horizontalPoint[1]];\n    }\n  }, {\n    key: \"_getMaxBounds\",\n    value: function _getMaxBounds() {\n      var bounds = this.props.maxBounds;\n\n      if (!bounds || !bounds.ne || !bounds.sw) {\n        return null;\n      }\n\n      return (0, _utils.toJSONString)(geoUtils.makeLatLngBounds(bounds.ne, bounds.sw));\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var props = (0, _extends2.default)({}, this.props);\n      var callbacks = {\n        onUserTrackingModeChange: props.onUserTrackingModeChange\n      };\n      return _react.default.createElement(RCTMGLCamera, (0, _extends2.default)({\n        testID: \"Camera\",\n        ref: \"camera\",\n        followUserLocation: this.props.followUserLocation,\n        followUserMode: this.props.followUserMode,\n        followUserPitch: this.props.followUserPitch,\n        followHeading: this.props.followHeading,\n        followZoomLevel: this.props.followZoomLevel,\n        stop: this._createStopConfig(props),\n        maxZoomLevel: this.props.maxZoomLevel,\n        minZoomLevel: this.props.minZoomLevel,\n        maxBounds: this._getMaxBounds(),\n        defaultStop: this._createDefaultCamera()\n      }, callbacks, {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 540,\n          columnNumber: 7\n        }\n      }));\n    }\n  }]);\n  return Camera;\n}(_react.default.Component);\n\nCamera.propTypes = _objectSpread({}, _utils.viewPropTypes, {\n  animationDuration: _propTypes.default.number,\n  animationMode: _propTypes.default.oneOf(['flyTo', 'easeTo', 'moveTo']),\n  defaultSettings: _propTypes.default.shape(SettingsPropTypes)\n}, SettingsPropTypes, {\n  minZoomLevel: _propTypes.default.number,\n  maxZoomLevel: _propTypes.default.number,\n  maxBounds: _propTypes.default.shape({\n    ne: _propTypes.default.arrayOf(_propTypes.default.number).isRequired,\n    sw: _propTypes.default.arrayOf(_propTypes.default.number).isRequired\n  }),\n  followUserLocation: _propTypes.default.bool,\n  followUserMode: _propTypes.default.oneOf(['normal', 'compass', 'course']),\n  followZoomLevel: _propTypes.default.number,\n  followPitch: _propTypes.default.number,\n  followHeading: _propTypes.default.number,\n  triggerKey: _propTypes.default.any,\n  alignment: _propTypes.default.arrayOf(_propTypes.default.number),\n  onUserTrackingModeChange: _propTypes.default.func\n});\nCamera.defaultProps = {\n  animationMode: 'easeTo',\n  animationDuration: 2000,\n  isUserInteraction: false\n};\nCamera.Mode = {\n  Flight: 'flyTo',\n  Move: 'moveTo',\n  Ease: 'easeTo'\n};\nvar RCTMGLCamera = (0, _reactNative.requireNativeComponent)(NATIVE_MODULE_NAME, Camera, {\n  nativeOnly: {\n    stop: true\n  }\n});\nCamera.UserTrackingModes = {\n  Follow: 'normal',\n  FollowWithHeading: 'compass',\n  FollowWithCourse: 'course'\n};\nvar _default = Camera;\nexports.default = _default;","map":{"version":3,"sources":["/Users/angelaranibar/Erick/ParqueosCochalosMovil-master/Movil/ParqueosCochalos/node_modules/@react-native-mapbox-gl/maps/javascript/components/Camera.js"],"names":["MapboxGL","NativeModules","MGLModule","NATIVE_MODULE_NAME","SettingsPropTypes","centerCoordinate","PropTypes","arrayOf","number","heading","pitch","bounds","shape","ne","isRequired","sw","paddingLeft","paddingRight","paddingTop","paddingBottom","zoomLevel","Camera","nextProps","_handleCameraChange","props","currentCamera","nextCamera","hasCameraChanged","_hasCameraChanged","followUserLocation","refs","camera","setNativeProps","followUserMode","followPitch","followHeading","followZoomLevel","cameraConfig","animationMode","animationDuration","_hasBoundsChanged","_setCamera","c","n","hasDefaultPropsChanged","_hasCenterCoordinateChanged","triggerKey","hasFollowPropsChanged","hasAnimationPropsChanged","cC","nC","isLngDiff","isLatDiff","cB","nB","northEastCoordinates","southWestCoordinates","padding","pad","Array","isArray","length","setCamera","Mode","Ease","coordinates","Flight","config","stops","stop","push","_createStopConfig","defaultCamera","defaultSettings","Move","ignoreFollowUserLocation","stopConfig","mode","_getNativeCameraMode","duration","zoom","geoUtils","makePoint","makeLatLngBounds","boundsPaddingTop","boundsPaddingRight","boundsPaddingBottom","boundsPaddingLeft","CameraModes","None","coordinate","region","getOrCalculateVisibleRegion","_mapWidth","_mapHeight","_region","topLeftCorner","topRightCorner","bottomLeftCorner","verticalLineString","makeLineString","horizontalLineString","distVertical","calculateDistance","distHorizontal","verticalPoint","pointAlongLine","alignment","horizontalPoint","maxBounds","callbacks","onUserTrackingModeChange","followUserPitch","maxZoomLevel","minZoomLevel","_getMaxBounds","_createDefaultCamera","React","Component","propTypes","viewPropTypes","oneOf","bool","any","func","defaultProps","isUserInteraction","RCTMGLCamera","nativeOnly","UserTrackingModes","Follow","FollowWithHeading","FollowWithCourse"],"mappings":"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","sourcesContent":["import React from 'react';\nimport PropTypes from 'prop-types';\nimport {NativeModules, requireNativeComponent} from 'react-native';\n\nimport {toJSONString, viewPropTypes, existenceChange} from '../utils';\nimport * as geoUtils from '../utils/geoUtils';\n\nconst MapboxGL = NativeModules.MGLModule;\n\nexport const NATIVE_MODULE_NAME = 'RCTMGLCamera';\n\nconst SettingsPropTypes = {\n  /**\n   * Center coordinate on map [lng, lat]\n   */\n  centerCoordinate: PropTypes.arrayOf(PropTypes.number),\n\n  /**\n   * Heading on map\n   */\n  heading: PropTypes.number,\n\n  /**\n   * Pitch on map\n   */\n  pitch: PropTypes.number,\n\n  bounds: PropTypes.shape({\n    /**\n     * northEastCoordinates - North east coordinate of bound\n     */\n    ne: PropTypes.arrayOf(PropTypes.number).isRequired,\n\n    /**\n     * southWestCoordinates - North east coordinate of bound\n     */\n    sw: PropTypes.arrayOf(PropTypes.number).isRequired,\n\n    /**\n     * Left camera padding for bounds\n     */\n    paddingLeft: PropTypes.number,\n\n    /**\n     * Right camera padding for bounds\n     */\n    paddingRight: PropTypes.number,\n\n    /**\n     * Top camera padding for bounds\n     */\n    paddingTop: PropTypes.number,\n\n    /**\n     * Bottom camera padding for bounds\n     */\n    paddingBottom: PropTypes.number,\n  }),\n\n  /**\n   * Zoom level of the map\n   */\n  zoomLevel: PropTypes.number,\n};\n\nclass Camera extends React.Component {\n  static propTypes = {\n    ...viewPropTypes,\n\n    animationDuration: PropTypes.number,\n\n    animationMode: PropTypes.oneOf(['flyTo', 'easeTo', 'moveTo']),\n\n    // default - view settings\n    defaultSettings: PropTypes.shape(SettingsPropTypes),\n\n    // normal - view settings\n    ...SettingsPropTypes,\n\n    minZoomLevel: PropTypes.number,\n    maxZoomLevel: PropTypes.number,\n\n    /**\n     * Restrict map panning so that the center is within these bounds\n     */\n    maxBounds: PropTypes.shape({\n      /**\n       * northEastCoordinates - North east coordinate of bound\n       */\n      ne: PropTypes.arrayOf(PropTypes.number).isRequired,\n\n      /**\n       * southWestCoordinates - South west coordinate of bound\n       */\n      sw: PropTypes.arrayOf(PropTypes.number).isRequired,\n    }),\n\n    /**\n     * Should the map orientation follow the user's.\n     */\n    followUserLocation: PropTypes.bool,\n\n    /**\n     * The mode used to track the user location on the map. One of; \"normal\", \"compass\", \"course\". Each mode string is also available as a member on the `MapboxGL.UserTrackingModes` object. `Follow` (normal), `FollowWithHeading` (compass), `FollowWithCourse` (course). NOTE: `followUserLocation` must be set to `true` for any of the modes to take effect. [Example](../example/src/examples/SetUserTrackingModes.js)\n     */\n    followUserMode: PropTypes.oneOf(['normal', 'compass', 'course']),\n\n    followZoomLevel: PropTypes.number,\n    followPitch: PropTypes.number,\n    followHeading: PropTypes.number,\n\n    // manual update\n    triggerKey: PropTypes.any,\n\n    // position\n    alignment: PropTypes.arrayOf(PropTypes.number),\n\n    // Triggered when the\n    onUserTrackingModeChange: PropTypes.func,\n  };\n\n  static defaultProps = {\n    animationMode: 'easeTo',\n    animationDuration: 2000,\n    isUserInteraction: false,\n  };\n\n  static Mode = {\n    Flight: 'flyTo',\n    Move: 'moveTo',\n    Ease: 'easeTo',\n  };\n\n  UNSAFE_componentWillReceiveProps(nextProps) {\n    this._handleCameraChange(this.props, nextProps);\n  }\n\n  shouldComponentUpdate() {\n    return false;\n  }\n\n  _handleCameraChange(currentCamera, nextCamera) {\n    const hasCameraChanged = this._hasCameraChanged(currentCamera, nextCamera);\n    if (!hasCameraChanged) {\n      return;\n    }\n\n    if (currentCamera.followUserLocation && !nextCamera.followUserLocation) {\n      this.refs.camera.setNativeProps({followUserLocation: false});\n      return;\n    }\n    if (!currentCamera.followUserLocation && nextCamera.followUserLocation) {\n      this.refs.camera.setNativeProps({followUserLocation: true});\n    }\n\n    if (nextCamera.followUserLocation) {\n      this.refs.camera.setNativeProps({\n        followUserMode: nextCamera.followUserMode,\n        followPitch: nextCamera.followPitch || nextCamera.pitch,\n        followHeading: nextCamera.followHeading || nextCamera.heading,\n        followZoomLevel: nextCamera.followZoomLevel || nextCamera.zoomLevel,\n      });\n      return;\n    }\n\n    const cameraConfig = {\n      animationMode: nextCamera.animationMode,\n      animationDuration: nextCamera.animationDuration,\n      zoomLevel: nextCamera.zoomLevel,\n      pitch: nextCamera.pitch,\n      heading: nextCamera.heading,\n    };\n\n    if (\n      nextCamera.bounds &&\n      this._hasBoundsChanged(currentCamera, nextCamera)\n    ) {\n      cameraConfig.bounds = nextCamera.bounds;\n    } else {\n      cameraConfig.centerCoordinate = nextCamera.centerCoordinate;\n    }\n\n    this._setCamera(cameraConfig);\n  }\n\n  _hasCameraChanged(currentCamera, nextCamera) {\n    const c = currentCamera;\n    const n = nextCamera;\n\n    const hasDefaultPropsChanged =\n      c.heading !== n.heading ||\n      this._hasCenterCoordinateChanged(c, n) ||\n      this._hasBoundsChanged(c, n) ||\n      c.pitch !== n.pitch ||\n      c.zoomLevel !== n.zoomLevel ||\n      c.triggerKey !== n.triggerKey;\n\n    const hasFollowPropsChanged =\n      c.followUserLocation !== n.followUserLocation ||\n      c.followUserMode !== n.followUserMode ||\n      c.followZoomLevel !== n.followZoomLevel ||\n      c.followHeading !== n.followHeading ||\n      c.followPitch !== n.followPitch;\n\n    const hasAnimationPropsChanged =\n      c.animationMode !== n.animationMode ||\n      c.animationDuration !== n.animationDuration;\n\n    return (\n      hasDefaultPropsChanged ||\n      hasFollowPropsChanged ||\n      hasAnimationPropsChanged\n    );\n  }\n\n  _hasCenterCoordinateChanged(currentCamera, nextCamera) {\n    const cC = currentCamera.centerCoordinate;\n    const nC = nextCamera.centerCoordinate;\n\n    if (existenceChange(cC, nC)) {\n      return true;\n    }\n\n    if (!cC && !nC) {\n      return false;\n    }\n\n    const isLngDiff =\n      currentCamera.centerCoordinate[0] !== nextCamera.centerCoordinate[0];\n    const isLatDiff =\n      currentCamera.centerCoordinate[1] !== nextCamera.centerCoordinate[1];\n    return isLngDiff || isLatDiff;\n  }\n\n  _hasBoundsChanged(currentCamera, nextCamera) {\n    const cB = currentCamera.bounds;\n    const nB = nextCamera.bounds;\n\n    if (!cB && !nB) {\n      return false;\n    }\n\n    if (existenceChange(cB, nB)) {\n      return true;\n    }\n\n    return (\n      cB.ne[0] !== nB.ne[0] ||\n      cB.ne[1] !== nB.ne[1] ||\n      cB.sw[0] !== nB.sw[0] ||\n      cB.sw[1] !== nB.sw[1] ||\n      cB.paddingTop !== nB.paddingTop ||\n      cB.paddingLeft !== nB.paddingLeft ||\n      cB.paddingRight !== nB.paddingRight ||\n      cB.paddingBottom !== nB.paddingBottom\n    );\n  }\n\n  /**\n   * Map camera transitions to fit provided bounds\n   *\n   * @example\n   * this.camera.fitBounds([lng, lat], [lng, lat])\n   * this.camera.fitBounds([lng, lat], [lng, lat], 20, 1000) // padding for all sides\n   * this.camera.fitBounds([lng, lat], [lng, lat], [verticalPadding, horizontalPadding], 1000)\n   * this.camera.fitBounds([lng, lat], [lng, lat], [top, right, bottom, left], 1000)\n   *\n   * @param {Array<Number>} northEastCoordinates - North east coordinate of bound\n   * @param {Array<Number>} southWestCoordinates - South west coordinate of bound\n   * @param {Number=} padding - Camera padding for bound\n   * @param {Number=} animationDuration - Duration of camera animation\n   * @return {void}\n   */\n  fitBounds(\n    northEastCoordinates,\n    southWestCoordinates,\n    padding = 0,\n    animationDuration = 0.0,\n  ) {\n    const pad = {\n      paddingLeft: 0,\n      paddingRight: 0,\n      paddingTop: 0,\n      paddingBottom: 0,\n    };\n\n    if (Array.isArray(padding)) {\n      if (padding.length === 2) {\n        pad.paddingTop = padding[0];\n        pad.paddingBottom = padding[0];\n        pad.paddingLeft = padding[1];\n        pad.paddingRight = padding[1];\n      } else if (padding.length === 4) {\n        pad.paddingTop = padding[0];\n        pad.paddingRight = padding[1];\n        pad.paddingBottom = padding[2];\n        pad.paddingLeft = padding[3];\n      }\n    } else {\n      pad.paddingLeft = padding;\n      pad.paddingRight = padding;\n      pad.paddingTop = padding;\n      pad.paddingBottom = padding;\n    }\n\n    return this.setCamera({\n      bounds: {\n        ne: northEastCoordinates,\n        sw: southWestCoordinates,\n        ...pad,\n      },\n      animationDuration,\n      animationMode: Camera.Mode.Ease,\n    });\n  }\n\n  /**\n   * Map camera will fly to new coordinate\n   *\n   * @example\n   * this.camera.flyTo([lng, lat])\n   * this.camera.flyTo([lng, lat], 12000)\n   *\n   *  @param {Array<Number>} coordinates - Coordinates that map camera will jump too\n   *  @param {Number=} animationDuration - Duration of camera animation\n   *  @return {void}\n   */\n  flyTo(coordinates, animationDuration = 2000) {\n    return this.setCamera({\n      centerCoordinate: coordinates,\n      animationDuration,\n      animationMode: Camera.Mode.Flight,\n    });\n  }\n\n  /**\n   * Map camera will move to new coordinate at the same zoom level\n   *\n   * @example\n   * this.camera.moveTo([lng, lat], 200) // eases camera to new location based on duration\n   * this.camera.moveTo([lng, lat]) // snaps camera to new location without any easing\n   *\n   *  @param {Array<Number>} coordinates - Coordinates that map camera will move too\n   *  @param {Number=} animationDuration - Duration of camera animation\n   *  @return {void}\n   */\n  moveTo(coordinates, animationDuration = 0) {\n    return this._setCamera({\n      centerCoordinate: coordinates,\n      animationDuration,\n    });\n  }\n\n  /**\n   * Map camera will zoom to specified level\n   *\n   * @example\n   * this.camera.zoomTo(16)\n   * this.camera.zoomTo(16, 100)\n   *\n   * @param {Number} zoomLevel - Zoom level that the map camera will animate too\n   * @param {Number=} animationDuration - Duration of camera animation\n   * @return {void}\n   */\n  zoomTo(zoomLevel, animationDuration = 2000) {\n    return this._setCamera({\n      zoomLevel,\n      animationDuration,\n      animationMode: Camera.Mode.Flight,\n    });\n  }\n\n  /**\n   * Map camera will perform updates based on provided config. Advanced use only!\n   *\n   * @example\n   * this.camera.setCamera({\n   *   centerCoordinate: [lng, lat],\n   *   zoomLevel: 16,\n   *   animationDuration: 2000,\n   * })\n   *\n   * this.camera.setCamera({\n   *   stops: [\n   *     { pitch: 45, animationDuration: 200 },\n   *     { heading: 180, animationDuration: 300 },\n   *   ]\n   * })\n   *\n   *  @param {Object} config - Camera configuration\n   */\n  setCamera(config = {}) {\n    this._setCamera(config);\n  }\n\n  _setCamera(config = {}) {\n    let cameraConfig = {};\n\n    if (config.stops) {\n      cameraConfig.stops = [];\n\n      for (const stop of config.stops) {\n        cameraConfig.stops.push(this._createStopConfig(stop));\n      }\n    } else {\n      cameraConfig = this._createStopConfig(config);\n    }\n\n    this.refs.camera.setNativeProps({stop: cameraConfig});\n  }\n\n  _createDefaultCamera() {\n    if (this.defaultCamera) {\n      return this.defaultCamera;\n    }\n    if (!this.props.defaultSettings) {\n      return null;\n    }\n\n    this.defaultCamera = this._createStopConfig(\n      {\n        ...this.props.defaultSettings,\n        animationMode: Camera.Mode.Move,\n      },\n      true,\n    );\n    return this.defaultCamera;\n  }\n\n  _createStopConfig(config = {}, ignoreFollowUserLocation = false) {\n    if (this.props.followUserLocation && !ignoreFollowUserLocation) {\n      return null;\n    }\n\n    const stopConfig = {\n      mode: this._getNativeCameraMode(config),\n      pitch: config.pitch,\n      heading: config.heading,\n      duration: config.animationDuration || 0,\n      zoom: config.zoomLevel,\n    };\n\n    if (config.centerCoordinate) {\n      stopConfig.centerCoordinate = toJSONString(\n        geoUtils.makePoint(config.centerCoordinate),\n      );\n    }\n\n    if (config.bounds && config.bounds.ne && config.bounds.sw) {\n      const {\n        ne,\n        sw,\n        paddingLeft,\n        paddingRight,\n        paddingTop,\n        paddingBottom,\n      } = config.bounds;\n      stopConfig.bounds = toJSONString(geoUtils.makeLatLngBounds(ne, sw));\n      stopConfig.boundsPaddingTop = paddingTop || 0;\n      stopConfig.boundsPaddingRight = paddingRight || 0;\n      stopConfig.boundsPaddingBottom = paddingBottom || 0;\n      stopConfig.boundsPaddingLeft = paddingLeft || 0;\n    }\n\n    return stopConfig;\n  }\n\n  _getNativeCameraMode(config) {\n    switch (config.animationMode) {\n      case Camera.Mode.Flight:\n        return MapboxGL.CameraModes.Flight;\n      case Camera.Mode.Move:\n        return MapboxGL.CameraModes.None;\n      default:\n        return MapboxGL.CameraModes.Ease;\n    }\n  }\n\n  _getAlignment(coordinate, zoomLevel) {\n    const region = geoUtils.getOrCalculateVisibleRegion(\n      coordinate,\n      zoomLevel,\n      this.props._mapWidth,\n      this.props._mapHeight,\n      this.props._region,\n    );\n\n    const topLeftCorner = [region.sw[0], region.ne[1]];\n    const topRightCorner = [region.ne[0], region.ne[1]];\n    const bottomLeftCorner = [region.sw[0], region.sw[1]];\n\n    const verticalLineString = geoUtils.makeLineString([\n      topLeftCorner,\n      bottomLeftCorner,\n    ]);\n\n    const horizontalLineString = geoUtils.makeLineString([\n      topLeftCorner,\n      topRightCorner,\n    ]);\n\n    const distVertical = geoUtils.calculateDistance(\n      topLeftCorner,\n      bottomLeftCorner,\n    );\n    const distHorizontal = geoUtils.calculateDistance(\n      topLeftCorner,\n      topRightCorner,\n    );\n\n    const verticalPoint = geoUtils.pointAlongLine(\n      verticalLineString,\n      distVertical * this.props.alignment[0],\n    );\n\n    const horizontalPoint = geoUtils.pointAlongLine(\n      horizontalLineString,\n      distHorizontal * this.props.alignment[1],\n    );\n\n    return [verticalPoint[0], horizontalPoint[1]];\n  }\n\n  _getMaxBounds() {\n    const bounds = this.props.maxBounds;\n    if (!bounds || !bounds.ne || !bounds.sw) {\n      return null;\n    }\n    return toJSONString(geoUtils.makeLatLngBounds(bounds.ne, bounds.sw));\n  }\n\n  render() {\n    const props = Object.assign({}, this.props);\n\n    const callbacks = {\n      onUserTrackingModeChange: props.onUserTrackingModeChange,\n    };\n\n    return (\n      <RCTMGLCamera\n        testID=\"Camera\"\n        ref=\"camera\"\n        followUserLocation={this.props.followUserLocation}\n        followUserMode={this.props.followUserMode}\n        followUserPitch={this.props.followUserPitch}\n        followHeading={this.props.followHeading}\n        followZoomLevel={this.props.followZoomLevel}\n        stop={this._createStopConfig(props)}\n        maxZoomLevel={this.props.maxZoomLevel}\n        minZoomLevel={this.props.minZoomLevel}\n        maxBounds={this._getMaxBounds()}\n        defaultStop={this._createDefaultCamera()}\n        {...callbacks}\n      />\n    );\n  }\n}\n\nconst RCTMGLCamera = requireNativeComponent(NATIVE_MODULE_NAME, Camera, {\n  nativeOnly: {\n    stop: true,\n  },\n});\n\nCamera.UserTrackingModes = {\n  Follow: 'normal',\n  FollowWithHeading: 'compass',\n  FollowWithCourse: 'course',\n};\n\nexport default Camera;\n"]},"metadata":{},"sourceType":"script"}